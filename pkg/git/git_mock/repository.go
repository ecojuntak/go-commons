// Code generated by mockery 2.9.0. DO NOT EDIT.

package git_mock

import (
	object "github.com/go-git/go-git/v5/plumbing/object"
	mock "github.com/stretchr/testify/mock"

	v5 "github.com/go-git/go-git/v5"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

// Add provides a mock function with given fields: path
func (_m *Repository) Add(path string) (string, error) {
	ret := _m.Called(path)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddAllAndCommit provides a mock function with given fields: message, author
func (_m *Repository) AddAllAndCommit(message string, author *object.Signature) (string, error) {
	ret := _m.Called(message, author)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, *object.Signature) string); ok {
		r0 = rf(message, author)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *object.Signature) error); ok {
		r1 = rf(message, author)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckoutBranch provides a mock function with given fields: name
func (_m *Repository) CheckoutBranch(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckoutTag provides a mock function with given fields: name
func (_m *Repository) CheckoutTag(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Commit provides a mock function with given fields: message, author
func (_m *Repository) Commit(message string, author *object.Signature) (string, error) {
	ret := _m.Called(message, author)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, *object.Signature) string); ok {
		r0 = rf(message, author)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *object.Signature) error); ok {
		r1 = rf(message, author)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBranch provides a mock function with given fields: name
func (_m *Repository) CreateBranch(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTag provides a mock function with given fields: name
func (_m *Repository) CreateTag(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GitRepository provides a mock function with given fields:
func (_m *Repository) GitRepository() *v5.Repository {
	ret := _m.Called()

	var r0 *v5.Repository
	if rf, ok := ret.Get(0).(func() *v5.Repository); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v5.Repository)
		}
	}

	return r0
}

// Option provides a mock function with given fields:
func (_m *Repository) Option() *v5.CloneOptions {
	ret := _m.Called()

	var r0 *v5.CloneOptions
	if rf, ok := ret.Get(0).(func() *v5.CloneOptions); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v5.CloneOptions)
		}
	}

	return r0
}

// PushDefault provides a mock function with given fields:
func (_m *Repository) PushDefault() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveBranch provides a mock function with given fields: name
func (_m *Repository) RemoveBranch(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveTag provides a mock function with given fields: name
func (_m *Repository) RemoveTag(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
